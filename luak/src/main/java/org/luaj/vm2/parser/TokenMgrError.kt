/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 5.0 */
/* JavaCCOptions: */
package org.luaj.vm2.parser

/** Token Manager Error.  */
class TokenMgrError : Error {

    /**
     * Indicates the reason why the exception is thrown. It will have
     * one of the above 4 values.
     */
    internal var errorCode: Int = 0

    /*
   * Constructors of various flavors follow.
   */

    /** No arg constructor.  */
    constructor() {}

    /** Constructor with message and reason.  */
    constructor(message: String, reason: Int) : super(message) {
        errorCode = reason
    }

    /** Full Constructor.  */
    constructor(
        EOFSeen: Boolean,
        lexState: Int,
        errorLine: Int,
        errorColumn: Int,
        errorAfter: String,
        curChar: Char,
        reason: Int
    ) : this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason) {
    }

    companion object {

        /**
         * The version identifier for this Serializable class.
         * Increment only if the *serialized* form of the
         * class changes.
         */
        private val serialVersionUID = 1L

        /*
   * Ordinals for various reasons why an Error of this type can be thrown.
   */

        /**
         * Lexical error occurred.
         */
        @JvmField
        val LEXICAL_ERROR = 0

        /**
         * An attempt was made to create a second instance of a static token manager.
         */
        @JvmField
        val STATIC_LEXER_ERROR = 1

        /**
         * Tried to change to an invalid lexical state.
         */
        @JvmField
        val INVALID_LEXICAL_STATE = 2

        /**
         * Detected (and bailed out of) an infinite loop in the token manager.
         */
        @JvmField
        val LOOP_DETECTED = 3

        /**
         * Replaces unprintable characters by their escaped (or unicode escaped)
         * equivalents in the given string
         */
        @JvmStatic
        protected fun addEscapes(str: String): String {
            val retval = StringBuffer()
            var ch: Char
            loop@for (i in 0 until str.length) {
                when (str[i]) {
                    '\u0000' -> continue@loop
                    '\b' -> {
                        retval.append("\\b")
                        continue@loop
                    }
                    '\t' -> {
                        retval.append("\\t")
                        continue@loop
                    }
                    '\n' -> {
                        retval.append("\\n")
                        continue@loop
                    }
                    //'\f' -> {
                    '\u000c' -> {
                        retval.append("\\f")
                        continue@loop
                    }
                    '\r' -> {
                        retval.append("\\r")
                        continue@loop
                    }
                    '\"' -> {
                        retval.append("\\\"")
                        continue@loop
                    }
                    '\'' -> {
                        retval.append("\\\'")
                        continue@loop
                    }
                    '\\' -> {
                        retval.append("\\\\")
                        continue@loop
                    }
                    else -> {
                        if (run {
                                ch = str[i]
                                (ch).toInt() < 0x20
                            }|| ch.toInt() > 0x7e) {
                            val s = "0000" + Integer.toString(ch.toInt(), 16)
                            retval.append("\\u" + s.substring(s.length - 4, s.length))
                        } else {
                            retval.append(ch)
                        }
                        continue@loop
                    }
                }
            }
            return retval.toString()
        }

        /**
         * Returns a detailed message for the Error when it is thrown by the
         * token manager to indicate a lexical error.
         * Parameters :
         * EOFSeen     : indicates if EOF caused the lexical error
         * curLexState : lexical state in which this error occurred
         * errorLine   : line number when the error occurred
         * errorColumn : column number when the error occurred
         * errorAfter  : prefix that was seen before this error occurred
         * curchar     : the offending character
         * Note: You can customize the lexical error message by modifying this method.
         */
        @JvmStatic
        protected fun LexicalError(
            EOFSeen: Boolean,
            lexState: Int,
            errorLine: Int,
            errorColumn: Int,
            errorAfter: String,
            curChar: Char
        ): String {
            return "Lexical error at line " +
                    errorLine + ", column " +
                    errorColumn + ".  Encountered: " +
                    (if (EOFSeen) "<EOF> " else "\"" + addEscapes(curChar.toString()) + "\"" + " (" + curChar.toInt() + "), ") +
                    "after : \"" + addEscapes(errorAfter) + "\""
        }
    }
}
/* JavaCC - OriginalChecksum=bd3720425dc7b44a5223b12676db358c (do not edit this line) */
